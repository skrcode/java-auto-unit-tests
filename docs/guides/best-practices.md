# Best Practices for Using JAIPilot

Get the most out of JAIPilot with these proven tips and best practices from experienced users.

## Code Preparation

### Write Testable Code

JAIPilot generates better tests for well-structured code:

**Good:**
```java
public class OrderService {
    private final OrderRepository repository;
    private final EmailService emailService;

    public OrderService(OrderRepository repository, EmailService emailService) {
        this.repository = repository;
        this.emailService = emailService;
    }

    public Order createOrder(OrderRequest request) {
        Order order = new Order(request);
        repository.save(order);
        emailService.sendConfirmation(order);
        return order;
    }
}
```

**Less Ideal:**
```java
public class OrderService {
    public Order createOrder(OrderRequest request) {
        Order order = new Order(request);
        // Directly instantiating dependencies
        new OrderRepository().save(order);
        new EmailService().sendConfirmation(order);
        return order;
    }
}
```

### Use Dependency Injection

Constructor injection makes code more testable:

```java
// âœ… Good - Easy to test
public class UserService {
    private final UserRepository repository;

    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}

// âŒ Less ideal - Hard to test
public class UserService {
    private UserRepository repository = new UserRepository();
}
```

### Keep Methods Focused

Smaller, focused methods are easier to test:

```java
// âœ… Good - Single responsibility
public boolean isEligible(User user) {
    return user.getAge() >= 18 && user.hasCompletedProfile();
}

public void processEligibleUsers(List<User> users) {
    users.stream()
        .filter(this::isEligible)
        .forEach(this::process);
}

// âŒ Less ideal - Too much in one method
public void processUsers(List<User> users) {
    for (User user : users) {
        if (user.getAge() >= 18 && user.hasCompletedProfile()) {
            // ... complex processing logic
        }
    }
}
```

## Using JAIPilot Effectively

### Start with Simple Classes

When first using JAIPilot:
1. Begin with simple utility classes
2. Verify the generated tests
3. Learn JAIPilot's patterns
4. Gradually move to complex classes

### Generate Tests Incrementally

Don't generate tests for your entire codebase at once:

```
Day 1: Core utilities and models
Day 2: Services with simple dependencies
Day 3: Controllers and complex business logic
Day 4: Integration points and edge cases
```

### Review Before Committing

Always review generated tests before committing:

**Checklist:**
- [ ] Tests compile and run
- [ ] Assertions are meaningful
- [ ] Edge cases are covered
- [ ] Mocks behave correctly
- [ ] Test names are descriptive
- [ ] No flaky tests (random failures)

### Customize Generated Tests

JAIPilot provides a solid foundation. Enhance it:

```java
// Generated by JAIPilot
@Test
void testCalculateDiscount() {
    assertEquals(10.0, calculator.calculateDiscount(100.0, 0.1));
}

// Enhanced with more context
@Test
void testCalculateDiscount_TenPercent_OnHundredDollars() {
    double originalPrice = 100.0;
    double discountRate = 0.1; // 10%
    double expectedDiscount = 10.0;

    double actualDiscount = calculator.calculateDiscount(originalPrice, discountRate);

    assertEquals(expectedDiscount, actualDiscount, 0.001,
        "10% discount on $100 should be $10");
}
```

## Test Maintenance

### Keep Tests in Sync

When updating code:
1. Update tests manually OR
2. Regenerate tests with JAIPilot
3. Merge useful manually-written tests with generated ones

### Use Version Control Wisely

Commit strategy for AI-generated tests:

```bash
# Commit generated tests separately
git add src/test/java/com/example/CalculatorTest.java
git commit -m "test: Add JAIPilot-generated tests for Calculator"

# Then commit your manual enhancements
git add src/test/java/com/example/CalculatorTest.java
git commit -m "test: Enhance Calculator tests with business-specific cases"
```

### Document Manual Changes

When enhancing generated tests, add comments:

```java
// Generated by JAIPilot
@Test
void testProcess() {
    // test code
}

// Added manually - business requirement from JIRA-123
@Test
void testProcess_WithSpecialCustomerDiscount() {
    // custom test code
}
```

## Performance Optimization

### Batch Generation Strategically

For large codebases:

```
1. Profile first: Identify untested areas
2. Prioritize: Critical business logic first
3. Batch by module: Generate module by module
4. Review incrementally: Don't accumulate review debt
```

### Optimize IDE Settings

For better performance:

1. **Increase memory**: `Help` â†’ `Change Memory Settings` â†’ Set to 4GB+
2. **Exclude build directories**: `Settings` â†’ `Build` â†’ `Exclude` â†’ Add `build/`, `target/`
3. **Disable unnecessary plugins**: Keep only essential plugins enabled

### Manage API Usage

Monitor and optimize credit usage:

1. **Start with free tier**: Evaluate JAIPilot first
2. **Generate strategically**: Focus on high-value classes
3. **Use manual tests for simple cases**: Reserve JAIPilot for complex classes
4. **Monitor usage**: Check your usage dashboard regularly

## Team Collaboration

### Establish Team Standards

Create team guidelines:

```markdown
# Team Testing Guidelines

## When to Use JAIPilot
- Complex business logic classes
- Service classes with multiple dependencies
- Classes with >5 public methods

## When to Write Manual Tests
- Simple POJOs and DTOs
- One-line utility methods
- Integration tests
- UI tests

## Review Requirements
- All generated tests must be reviewed
- Add manual tests for business-specific scenarios
- Maintain minimum 80% code coverage
```

### Code Review Checklist

When reviewing AI-generated tests:

- [ ] Tests verify actual business requirements
- [ ] No obviously incorrect assertions
- [ ] Mocks don't hide real bugs
- [ ] Test names clearly describe what's being tested
- [ ] No duplicate or redundant tests
- [ ] Tests are deterministic (not flaky)

### Knowledge Sharing

Share learnings with your team:

1. **Weekly demos**: Show interesting test cases JAIPilot generated
2. **Documentation**: Document patterns and anti-patterns
3. **Pair review**: Review generated tests together
4. **Retros**: Discuss what works and what doesn't

## Common Pitfalls to Avoid

### Over-Reliance on Generated Tests

**âŒ Pitfall:**
```java
// Blindly accepting all generated tests without review
```

**âœ… Solution:**
```java
// Review and enhance generated tests with domain knowledge
// Add business-specific test cases manually
```

### Ignoring Test Failures

**âŒ Pitfall:**
```java
// Generated test fails, disable it and move on
@Test
@Disabled("Generated test fails")
void testSomething() { }
```

**âœ… Solution:**
```java
// Investigate why it fails - might indicate a real bug
// Fix the underlying issue or adjust the test appropriately
```

### Not Maintaining Tests

**âŒ Pitfall:**
- Generate tests once
- Never update as code evolves
- Tests become outdated

**âœ… Solution:**
- Regenerate tests when making major changes
- Keep tests in sync with code
- Review test coverage regularly

### Testing Implementation Details

**âŒ Pitfall:**
```java
// Testing internal implementation
@Test
void testInternalCache() {
    service.method();
    assertTrue(service.cacheSize() > 0); // Testing internal detail
}
```

**âœ… Solution:**
```java
// Test behavior, not implementation
@Test
void testMethodPerformance_UsesCache() {
    service.method(); // First call
    long firstCallTime = measureExecutionTime(() -> service.method());

    service.method(); // Should be faster due to cache
    long secondCallTime = measureExecutionTime(() -> service.method());

    assertTrue(secondCallTime < firstCallTime);
}
```

## Integration with CI/CD

### Continuous Testing

Integrate generated tests into CI:

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '17'
      - name: Run tests
        run: ./gradlew test
      - name: Upload coverage
        run: ./gradlew jacocoTestReport
```

### Coverage Goals

Set realistic coverage targets:

- **New projects**: Start with 60-70%
- **Existing projects**: Gradually increase coverage
- **Critical modules**: Aim for 80-90%
- **Utilities**: Can aim for 95%+

## Advanced Tips

### Combining Manual and Generated Tests

Create a hybrid approach:

```java
public class OrderServiceTest {

    // Generated by JAIPilot
    @Nested
    @DisplayName("Generated Tests")
    class GeneratedTests {
        @Test
        void testCreateOrder() { }

        @Test
        void testCancelOrder() { }
    }

    // Written manually
    @Nested
    @DisplayName("Business Logic Tests")
    class BusinessLogicTests {
        @Test
        void testBlackFridayDiscounts() { }

        @Test
        void testBulkOrderProcessing() { }
    }
}
```

### Testing Patterns

Learn from generated patterns:

```java
// JAIPilot often generates this pattern for exception testing
@Test
void testMethod_ThrowsException_WhenInvalidInput() {
    Exception exception = assertThrows(CustomException.class,
        () -> service.method(invalidInput));

    assertTrue(exception.getMessage().contains("expected phrase"));
}

// Apply this pattern to your manual tests
```

### Refactoring Generated Tests

Extract common setup:

```java
// Before
@Test
void testA() {
    User user = new User("John", "john@example.com");
    user.setAge(25);
    // test logic
}

@Test
void testB() {
    User user = new User("John", "john@example.com");
    user.setAge(25);
    // test logic
}

// After
private User createStandardUser() {
    User user = new User("John", "john@example.com");
    user.setAge(25);
    return user;
}

@Test
void testA() {
    User user = createStandardUser();
    // test logic
}

@Test
void testB() {
    User user = createStandardUser();
    // test logic
}
```

## Next Steps

- Explore [Advanced Features](advanced-features.md)
- Check out [Examples](../examples/)
- Read about [JUnit Versions](junit-versions.md)

## Need Help?

- ğŸ“š [FAQ](../troubleshooting/faq.md)
- ğŸ’¬ [Discussions](https://github.com/skrcode/java-auto-unit-tests/discussions)
- ğŸ› [Report Issues](https://github.com/skrcode/java-auto-unit-tests/issues/new?template=bug_report.md)
